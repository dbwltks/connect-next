"use client";

import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Drawer,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerTitle,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { useMediaQuery } from "@/hooks/use-media-query";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Calendar as CalendarComponent } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import {
  Calendar,
  CalendarDays,
  ChevronLeft,
  ChevronRight,
  Clock,
  MapPin,
  Plus,
  Trash2,
  Edit,
  Settings,
  CheckCircle,
  Filter,
  Users,
} from "lucide-react";
import { SiGooglecalendar } from "react-icons/si";
import {
  format,
  addDays,
  addHours,
  startOfWeek,
  endOfWeek,
  startOfMonth,
  endOfMonth,
  eachDayOfInterval,
  isSameMonth,
  isSameDay,
  parseISO,
} from "date-fns";
import { ko } from "date-fns/locale";
import { formatHourToKorean, formatDateTimeToKorean, formatFullDateTimeToKorean } from "@/lib/time-format";
import {
  eventsApi,
  type Event,
} from "../utils/api";
import { createClient } from "@/utils/supabase/client";
import { loadProgramData } from "../utils/program-data";
import {
  initializeGoogleAPI,
  authenticateUser,
  syncMultipleEvents,
  createOrUpdateEvent,
  deleteAllConnectNextEvents,
} from "@/utils/google-calendar-api";

interface Team {
  id: string;
  name: string;
  description?: string;
  leader_id?: string;
  member_count: number;
  color?: string;
}

interface Program {
  id: string;
  name: string;
  category: string;
  start_date?: string;
  end_date?: string;
}

interface CalendarTabProps {
  programId: string;
  hasEditPermission?: boolean;
}

export default function CalendarTab({ 
  programId, 
  hasEditPermission = false,
}: CalendarTabProps) {
  // 반응형 디바이스 체크 (768px = md breakpoint)
  const isMobile = useMediaQuery("(max-width: 768px)");
  // State 관리
  const [events, setEvents] = useState<Event[]>([]);
  const [teams, setTeams] = useState<Team[]>([]);
  const [programs, setPrograms] = useState<Program[]>([]);
  const [selectedTeamFilter, setSelectedTeamFilter] = useState<string>("all");
  const [viewMode, setViewMode] = useState<"list" | "week" | "month">("list");
  const [currentDate, setCurrentDate] = useState(new Date());
  const [isEventModalOpen, setIsEventModalOpen] = useState(false);
  const [isEditingEvent, setIsEditingEvent] = useState(false);
  const [editingEventData, setEditingEventData] = useState<Event | null>(null);
  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);
  const [isEventDetailOpen, setIsEventDetailOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [eventToDelete, setEventToDelete] = useState<Event | null>(null);
  const [isLocationSettingsOpen, setIsLocationSettingsOpen] = useState(false);
  const [savedLocations, setSavedLocations] = useState<string[]>([]);
  const [newLocation, setNewLocation] = useState("");
  const [editingLocationIndex, setEditingLocationIndex] = useState<number | null>(null);
  const [editingLocationValue, setEditingLocationValue] = useState("");
  const [isSyncing, setIsSyncing] = useState(false);
  const [userRole, setUserRole] = useState<string>('guest');
  const [managePermissions, setManagePermissions] = useState<{ [key: string]: string[] }>({});
  const [isDayEventsModalOpen, setIsDayEventsModalOpen] = useState(false);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedDateEvents, setSelectedDateEvents] = useState<Event[]>([]);
  const [isEventDetailModalOpen, setIsEventDetailModalOpen] = useState(false);

  // 새 일정 폼 상태
  const [newEvent, setNewEvent] = useState({
    title: "",
    description: "",
    start_date: "",
    end_date: "",
    location: "",
    program_id: "",
    team_id: "",
    isRecurring: false,
    recurringEndDate: "",
  });

  // 반복 설정 상태
  const [recurringSettings, setRecurringSettings] = useState({
    frequency: "weekly" as "daily" | "weekly" | "monthly",
    interval: 1,
    daysOfWeek: [] as number[],
    dayOfMonth: 1,
  });

  // 데이터 로드
  useEffect(() => {
    const loadData = async () => {
      try {
        // 이벤트 로드
        const eventsData = await eventsApi.getAll(programId);
        setEvents(eventsData || []);

        // 프로그램 데이터 로드
        const programData = await loadProgramData(programId);
        if (programData) {
          if (programData.teams) {
            setTeams(Array.isArray(programData.teams) ? programData.teams : []);
          }
          // events_settings에서 장소 로드 (프로그램 위젯과 동일)
          if (programData.events_settings && programData.events_settings.locations) {
            setSavedLocations(Array.isArray(programData.events_settings.locations) ? programData.events_settings.locations : []);
          }
          
          // 프로그램 정보 설정
          const program: Program = {
            id: programData.id || programId,
            name: programData.name || "프로그램",
            category: programData.category || "일반",
            start_date: programData.start_date,
            end_date: programData.end_date,
          };
          setPrograms([program]);
        }
      } catch (error) {
        console.error('데이터 로드 실패:', error);
      }
    };

    loadData();
  }, [programId]);

  // 사용자 역할 로드
  useEffect(() => {
    const loadUserRole = async () => {
      try {
        const supabase = createClient();
        const { data: { user } } = await supabase.auth.getUser();
        
        if (user) {
          const { data: userData } = await supabase
            .from('users')
            .select('role, roles')
            .eq('id', user.id)
            .single();
          
          let userRoleValue = "member";
          
          if (userData?.roles && Array.isArray(userData.roles) && userData.roles.length > 0) {
            userRoleValue = userData.roles[0];
          } else if (userData?.role) {
            userRoleValue = userData.role;
          }
          
          setUserRole(userRoleValue);
        }
      } catch (error) {
        console.error('사용자 역할 로드 실패:', error);
        setUserRole('guest');
      }
    };

    loadUserRole();
  }, []);

  // 권한 확인 함수들
  const hasAdminPermission = () => {
    return ['admin', 'super_admin'].includes(userRole);
  };

  const hasRolePermission = (permissions: string[]) => {
    return permissions.includes(userRole);
  };

  // 주간 보기 날짜 계산
  const weekDays = eachDayOfInterval({
    start: startOfWeek(currentDate, { weekStartsOn: 0 }),
    end: endOfWeek(currentDate, { weekStartsOn: 0 }),
  });

  // 월간 보기 날짜 계산
  const monthDays = eachDayOfInterval({
    start: startOfWeek(startOfMonth(currentDate), { weekStartsOn: 0 }),
    end: endOfWeek(endOfMonth(currentDate), { weekStartsOn: 0 }),
  });

  // 특정 날짜의 이벤트 가져오기 (시간 순서대로 정렬)
  const getEventsForDay = (date: Date) => {
    return filteredEvents
      .filter((event) => {
        const eventDate = parseISO(event.start_date);
        return isSameDay(eventDate, date);
      })
      .sort((a, b) => {
        const timeA = parseISO(a.start_date);
        const timeB = parseISO(b.start_date);
        return timeA.getTime() - timeB.getTime();
      });
  };

  // 팀별 색상
  const getTeamColor = (teamId?: string) => {
    if (!teamId) {
      return "bg-gray-100 text-gray-800 border-gray-200";
    }

    const team = teams.find((t) => t.id === teamId);
    if (team?.color) {
      // hex 색상을 CSS 스타일로 변환
      return "";
    }

    const colors = [
      "bg-blue-100 text-blue-800 border-blue-200",
      "bg-green-100 text-green-800 border-green-200",
      "bg-purple-100 text-purple-800 border-purple-200",
      "bg-orange-100 text-orange-800 border-orange-200",
      "bg-pink-100 text-pink-800 border-pink-200",
      "bg-yellow-100 text-yellow-800 border-yellow-200",
      "bg-indigo-100 text-indigo-800 border-indigo-200",
      "bg-red-100 text-red-800 border-red-200",
    ];

    const teamIndex = teams.findIndex((t) => t.id === teamId);
    return colors[teamIndex % colors.length];
  };

  const getTeamStyle = (teamId?: string) => {
    if (!teamId) {
      // 팀이 선택되지 않았을 때 그래파이트 색상 사용
      return {
        backgroundColor: "#616161",
        borderColor: "#616161",
        color: "#ffffff",
      };
    }

    const team = teams.find((t) => t.id === teamId);
    if (team?.color) {
      return {
        backgroundColor: team.color,
        borderColor: team.color,
        color: "#ffffff",
      };
    }

    // 팀은 있지만 색상이 없을 때도 그래파이트 색상 사용
    return {
      backgroundColor: "#616161",
      borderColor: "#616161",
      color: "#ffffff",
    };
  };

  const navigateDate = (direction: "prev" | "next") => {
    if (viewMode === "week") {
      setCurrentDate((prev) => addDays(prev, direction === "next" ? 7 : -7));
    } else if (viewMode === "month") {
      setCurrentDate((prev) => {
        const newDate = new Date(prev);
        newDate.setMonth(prev.getMonth() + (direction === "next" ? 1 : -1));
        return newDate;
      });
    }
    // list 모드에서는 날짜 네비게이션 없음
  };

  // 일정 시간대 판단 함수
  const getEventTimeStatus = (eventDate: Date, endDate?: Date | null) => {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const eventDay = new Date(
      eventDate.getFullYear(),
      eventDate.getMonth(),
      eventDate.getDate()
    );

    // 디데이 계산 (일 단위 차이)
    const diffTime = eventDay.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    if (eventDay < today) {
      return {
        status: "past",
        label: "지난 일정",
        color: "text-gray-500",
        bgColor: "bg-gray-100",
        icon: "",
      };
    } else if (isSameDay(eventDay, today)) {
      // 오늘 일정인 경우 시간도 확인
      if (endDate && now > endDate) {
        return {
          status: "past",
          label: "완료",
          color: "text-gray-500",
          bgColor: "bg-gray-100",
          icon: "✓",
        };
      } else if (endDate && now >= eventDate && now <= endDate) {
        return {
          status: "ongoing",
          label: "진행중",
          color: "text-green-700",
          bgColor: "bg-green-100",
          icon: "●",
        };
      } else {
        return {
          status: "today",
          label: "오늘",
          color: "text-blue-700",
          bgColor: "bg-blue-100",
          icon: "●",
        };
      }
    } else {
      // 다가오는 일정에 대한 디데이 표시
      const getDDayLabel = (days: number) => {
        if (days === 1) return "D-1";
        if (days === 2) return "D-2";
        if (days === 3) return "D-3";
        if (days <= 7) return `D-${days}`;
        return "예정";
      };

      return {
        status: "upcoming",
        label: getDDayLabel(diffDays),
        color: "text-orange-700",
        bgColor: "bg-orange-100",
        icon: "",
      };
    }
  };

  const handleDateClick = (date: Date) => {
    const dayEvents = getEventsForDay(date);
    setSelectedDate(date);
    setSelectedDateEvents(dayEvents);
    setIsDayEventsModalOpen(true);
  };

  // handleSaveEvent 함수 추가
  const handleSaveEvent = async () => {
    if (!newEvent.title.trim() || !newEvent.start_date || !newEvent.end_date) {
      alert('제목, 시작 일시, 종료 일시는 필수입니다.');
      return;
    }

    try {
      const eventData = {
        ...newEvent,
        program_id: programId,
      };

      if (isEditingEvent && editingEventData) {
        await eventsApi.update(editingEventData.id, eventData);
      } else {
        if (newEvent.isRecurring) {
          // 반복 일정 생성 로직
          const events = generateRecurringEvents(eventData);
          for (const event of events) {
            await eventsApi.create(event);
          }
        } else {
          await eventsApi.create(eventData);
        }
      }

      // 데이터 새로고침
      const eventsData = await eventsApi.getAll(programId);
      setEvents(eventsData || []);

      // 모달 닫기
      setIsEventModalOpen(false);
      resetEventForm();
    } catch (error) {
      console.error('일정 저장 실패:', error);
      alert('일정 저장에 실패했습니다.');
    }
  };

  // 이벤트 필터링
  const filteredEvents = events.filter(event => {
    if (selectedTeamFilter === "all") return true;
    return event.team_id === selectedTeamFilter;
  });

  // 장소 관리 함수들
  const addLocation = async () => {
    if (!newLocation.trim() || savedLocations.includes(newLocation.trim())) return;
    
    try {
      const supabase = createClient();
      const updatedLocations = [...savedLocations, newLocation.trim()];

      // 현재 events_settings 가져오기
      const { data: currentData, error: fetchError } = await supabase
        .from("programs")
        .select("events_settings")
        .eq("id", programId)
        .single();

      if (fetchError) throw fetchError;

      const currentSettings = currentData?.events_settings || {};
      const updatedSettings = {
        ...currentSettings,
        locations: updatedLocations,
      };

      // events_settings 업데이트
      const { error } = await supabase
        .from("programs")
        .update({ events_settings: updatedSettings })
        .eq("id", programId);

      if (error) throw error;

      setSavedLocations(updatedLocations);
      setNewLocation("");
    } catch (error) {
      console.error('장소 저장 실패:', error);
    }
  };

  const removeLocation = async (locationToRemove: string) => {
    try {
      const supabase = createClient();
      const updatedLocations = savedLocations.filter((loc) => loc !== locationToRemove);

      // 현재 events_settings 가져오기
      const { data: currentData, error: fetchError } = await supabase
        .from("programs")
        .select("events_settings")
        .eq("id", programId)
        .single();

      if (fetchError) throw fetchError;

      const currentSettings = currentData?.events_settings || {};
      const updatedSettings = {
        ...currentSettings,
        locations: updatedLocations,
      };

      // events_settings 업데이트
      const { error } = await supabase
        .from("programs")
        .update({ events_settings: updatedSettings })
        .eq("id", programId);

      if (error) throw error;

      setSavedLocations(updatedLocations);
    } catch (error) {
      console.error('장소 삭제 실패:', error);
    }
  };

  const startEditLocation = (index: number, location: string) => {
    setEditingLocationIndex(index);
    setEditingLocationValue(location);
  };

  const saveEditLocation = async () => {
    if (editingLocationIndex === null || !editingLocationValue.trim()) return;

    // 중복 체크 (자기 자신 제외)
    const isDuplicate = savedLocations.some(
      (loc, index) =>
        index !== editingLocationIndex && loc === editingLocationValue.trim()
    );

    if (isDuplicate) {
      alert("이미 존재하는 장소명입니다.");
      return;
    }

    try {
      const supabase = createClient();
      const updatedLocations = [...savedLocations];
      updatedLocations[editingLocationIndex] = editingLocationValue.trim();

      // 현재 events_settings 가져오기
      const { data: currentData, error: fetchError } = await supabase
        .from("programs")
        .select("events_settings")
        .eq("id", programId)
        .single();

      if (fetchError) throw fetchError;

      const currentSettings = currentData?.events_settings || {};
      const updatedSettings = {
        ...currentSettings,
        locations: updatedLocations,
      };

      // events_settings 업데이트
      const { error } = await supabase
        .from("programs")
        .update({ events_settings: updatedSettings })
        .eq("id", programId);

      if (error) throw error;

      setSavedLocations(updatedLocations);
      setEditingLocationIndex(null);
      setEditingLocationValue("");
    } catch (error) {
      console.error('장소 수정 실패:', error);
    }
  };

  const cancelEditLocation = () => {
    setEditingLocationIndex(null);
    setEditingLocationValue("");
  };

  // 일정 관리 함수들
  const handleEventSubmit = async () => {
    if (!newEvent.title.trim() || !newEvent.start_date || !newEvent.end_date) {
      alert('제목, 시작 일시, 종료 일시는 필수입니다.');
      return;
    }

    try {
      const eventData = {
        ...newEvent,
        program_id: programId,
      };

      if (isEditingEvent && editingEventData) {
        await eventsApi.update(editingEventData.id, eventData);
      } else {
        if (newEvent.isRecurring) {
          // 반복 일정 생성 로직
          const events = generateRecurringEvents(eventData);
          for (const event of events) {
            await eventsApi.create(event);
          }
        } else {
          await eventsApi.create(eventData);
        }
      }

      // 데이터 새로고침
      const eventsData = await eventsApi.getAll(programId);
      setEvents(eventsData || []);

      // 모달 닫기
      setIsEventModalOpen(false);
      resetEventForm();
    } catch (error) {
      console.error('일정 저장 실패:', error);
      alert('일정 저장에 실패했습니다.');
    }
  };

  const generateRecurringEvents = (baseEvent: any) => {
    const events = [];
    const startDate = new Date(baseEvent.start_date);
    const endDate = new Date(baseEvent.recurringEndDate);
    const eventDuration = new Date(baseEvent.end_date).getTime() - new Date(baseEvent.start_date).getTime();

    let currentDate = new Date(startDate);

    while (currentDate <= endDate) {
      const eventEndDate = new Date(currentDate.getTime() + eventDuration);
      
      events.push({
        ...baseEvent,
        start_date: currentDate.toISOString(),
        end_date: eventEndDate.toISOString(),
      });

      // 다음 반복 날짜 계산
      if (recurringSettings.frequency === "daily") {
        currentDate = addDays(currentDate, recurringSettings.interval);
      } else if (recurringSettings.frequency === "weekly") {
        currentDate = addDays(currentDate, 7 * recurringSettings.interval);
      } else if (recurringSettings.frequency === "monthly") {
        currentDate.setMonth(currentDate.getMonth() + recurringSettings.interval);
      }
    }

    return events;
  };

  const resetEventForm = () => {
    setNewEvent({
      title: "",
      description: "",
      start_date: "",
      end_date: "",
      location: "",
      program_id: "",
      team_id: "",
      isRecurring: false,
      recurringEndDate: "",
    });
    setIsEditingEvent(false);
    setEditingEventData(null);
  };

  const handleEditEvent = (event: Event) => {
    setEditingEventData(event);
    setIsEditingEvent(true);
    setNewEvent({
      title: event.title,
      description: event.description || "",
      start_date: event.start_date ? format(new Date(event.start_date), "yyyy-MM-dd'T'HH:mm") : "",
      end_date: event.end_date ? format(new Date(event.end_date), "yyyy-MM-dd'T'HH:mm") : "",
      location: event.location || "",
      program_id: event.program_id,
      team_id: event.team_id || "",
      isRecurring: false,
      recurringEndDate: "",
    });
    setIsEventModalOpen(true);
  };

  const handleDeleteEvent = async (eventId: string) => {
    try {
      await eventsApi.delete(eventId);
      
      // 데이터 새로고침
      const eventsData = await eventsApi.getAll(programId);
      setEvents(eventsData || []);
      
      setIsEventDetailModalOpen(false);
    } catch (error) {
      console.error('일정 삭제 실패:', error);
      alert('일정 삭제에 실패했습니다.');
    }
  };

  // Google Calendar 동기화 함수들
  const syncEventsToGoogle = async () => {
    try {
      setIsSyncing(true);
      // TODO: Google Calendar API 연동 구현
      alert('Google Calendar 동기화 기능은 준비 중입니다.');
    } catch (error) {
      console.error('Google Calendar 동기화 실패:', error);
      alert('Google Calendar 동기화에 실패했습니다.');
    } finally {
      setIsSyncing(false);
    }
  };

  const deleteConnectNextEventsFromGoogle = async () => {
    try {
      setIsSyncing(true);
      // TODO: Google Calendar API 연동 구현
      alert('Google Calendar 일정 삭제 기능은 준비 중입니다.');
    } catch (error) {
      console.error('Google Calendar 일정 삭제 실패:', error);
      alert('Google Calendar 일정 삭제에 실패했습니다.');
    } finally {
      setIsSyncing(false);
    }
  };

  // 뷰 렌더링 함수들
  const renderListView = () => {
    const sortedEvents = [...filteredEvents].sort(
      (a, b) => new Date(a.start_date).getTime() - new Date(b.start_date).getTime()
    );

    if (sortedEvents.length === 0) {
      return (
        <div className="text-center py-8 text-muted-foreground">
          <Calendar className="h-8 w-8 mx-auto mb-2 opacity-50" />
          <p className="text-sm">등록된 일정이 없습니다.</p>
        </div>
      );
    }

    return (
      <div className="space-y-3">
        {sortedEvents.map((event) => (
          <Card key={event.id} className="cursor-pointer hover:shadow-md transition-shadow">
            <CardContent className="p-4">
              <div className="flex items-start justify-between">
                <div className="flex-1">
                  <h3 className="font-medium text-sm mb-1">{event.title}</h3>
                  {event.description && (
                    <p className="text-xs text-gray-600 mb-2">{event.description}</p>
                  )}
                  <div className="flex flex-wrap items-center gap-4 text-xs text-gray-500">
                    <div className="flex items-center gap-1">
                      <Clock size={12} />
                      {event.start_date && formatDateTimeToKorean(new Date(event.start_date))} ~{" "}
                      {event.end_date && formatDateTimeToKorean(new Date(event.end_date))}
                    </div>
                    {event.location && (
                      <div className="flex items-center gap-1">
                        <MapPin size={12} />
                        {event.location}
                      </div>
                    )}
                    {event.team_id && (
                      <div className="flex items-center gap-1">
                        <Users size={12} />
                        {teams.find(t => t.id === event.team_id)?.name || "팀"}
                      </div>
                    )}
                  </div>
                </div>
                <div className="flex items-center gap-1 ml-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={(e) => {
                      e.stopPropagation();
                      setSelectedEvent(event);
                      setIsEventDetailOpen(true);
                    }}
                    className="p-1 h-6 w-6"
                  >
                    <Calendar size={12} />
                  </Button>
                  {hasEditPermission && (
                    <>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleEditEvent(event);
                        }}
                        className="p-1 h-6 w-6"
                      >
                        <Edit size={12} />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={(e) => {
                          e.stopPropagation();
                          setEventToDelete(event);
                          setIsDeleteDialogOpen(true);
                        }}
                        className="p-1 h-6 w-6 text-red-500 hover:text-red-700"
                      >
                        <Trash2 size={12} />
                      </Button>
                    </>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    );
  };

  const renderWeekView = () => {
    const weekStart = startOfWeek(currentDate, { weekStartsOn: 0 });
    const weekEnd = endOfWeek(currentDate, { weekStartsOn: 0 });
    const days = eachDayOfInterval({ start: weekStart, end: weekEnd });

    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="font-medium">
            {format(weekStart, "M월 d일", { locale: ko })} - {format(weekEnd, "M월 d일", { locale: ko })}
          </h3>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentDate(addDays(currentDate, -7))}
            >
              <ChevronLeft size={16} />
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentDate(new Date())}
            >
              오늘
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentDate(addDays(currentDate, 7))}
            >
              <ChevronRight size={16} />
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-7 gap-2">
          {days.map((day) => {
            const dayEvents = filteredEvents.filter(event => 
              isSameDay(new Date(event.start_date), day)
            );

            return (
              <div key={day.toISOString()} className="border rounded-lg p-2 min-h-[100px]">
                <div className="font-medium text-sm mb-2">
                  {format(day, "d", { locale: ko })}
                  <span className="text-xs text-gray-500 ml-1">
                    ({format(day, "EEE", { locale: ko })})
                  </span>
                </div>
                <div className="space-y-1">
                  {dayEvents.map((event) => (
                    <div
                      key={event.id}
                      className="text-xs p-1 bg-blue-100 text-blue-800 rounded cursor-pointer hover:bg-blue-200"
                      onClick={() => {
                        setSelectedEvent(event);
                        setIsEventDetailOpen(true);
                      }}
                    >
                      {event.title}
                    </div>
                  ))}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  const renderMonthView = () => {
    const monthStart = startOfMonth(currentDate);
    const monthEnd = endOfMonth(currentDate);
    const calendarStart = startOfWeek(monthStart, { weekStartsOn: 0 });
    const calendarEnd = endOfWeek(monthEnd, { weekStartsOn: 0 });
    const days = eachDayOfInterval({ start: calendarStart, end: calendarEnd });

    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="font-medium">
            {format(currentDate, "yyyy년 M월", { locale: ko })}
          </h3>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentDate(addDays(currentDate, -30))}
            >
              <ChevronLeft size={16} />
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentDate(new Date())}
            >
              오늘
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentDate(addDays(currentDate, 30))}
            >
              <ChevronRight size={16} />
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-7 gap-1 mb-4">
          {['일', '월', '화', '수', '목', '금', '토'].map((day) => (
            <div key={day} className="text-center font-medium text-sm p-2">
              {day}
            </div>
          ))}
        </div>

        <div className="grid grid-cols-7 gap-1">
          {days.map((day) => {
            const dayEvents = filteredEvents.filter(event => 
              isSameDay(new Date(event.start_date), day)
            );
            const isCurrentMonth = isSameMonth(day, currentDate);
            const isToday = isSameDay(day, new Date());

            return (
              <div 
                key={day.toISOString()} 
                className={`border rounded p-1 min-h-[80px] ${
                  isCurrentMonth ? 'bg-white' : 'bg-gray-50'
                } ${isToday ? 'ring-2 ring-blue-500' : ''}`}
              >
                <div className={`text-sm font-medium mb-1 ${
                  isCurrentMonth ? 'text-black' : 'text-gray-400'
                }`}>
                  {format(day, "d")}
                </div>
                <div className="space-y-1">
                  {dayEvents.slice(0, 2).map((event) => (
                    <div
                      key={event.id}
                      className="text-xs p-1 bg-blue-100 text-blue-800 rounded cursor-pointer hover:bg-blue-200 truncate"
                      onClick={() => {
                        setSelectedEvent(event);
                        setIsEventDetailOpen(true);
                      }}
                    >
                      {event.title}
                    </div>
                  ))}
                  {dayEvents.length > 2 && (
                    <div className="text-xs text-gray-500">
                      +{dayEvents.length - 2}개
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-4 px-2 sm:px-4">
      <div className="space-y-4">
        {/* 상단 컨트롤 바 */}
        <div className="flex flex-col gap-2 sm:flex-row sm:justify-between sm:items-center">
          <div className="flex items-center gap-2">
            {/* 뷰 모드 탭 선택 */}
            <div className="relative flex bg-gray-100 rounded-lg p-1">
              {/* 슬라이딩 백그라운드 */}
              <div 
                className="absolute top-1 bottom-1 left-1 bg-white rounded-md shadow-sm transition-transform duration-300 ease-out"
                style={{
                  width: "calc((100% - 8px) / 3)",
                  transform: `translateX(${
                    viewMode === "list" ? "0%" : 
                    viewMode === "week" ? "100%" : 
                    "200%"
                  })`,
                }}
              />
              <Button
                onClick={() => setViewMode("list")}
                variant="ghost"
                size="sm"
                className={`relative z-10 flex-1 ${viewMode === "list" ? "text-black" : "text-gray-600"} hover:text-gray-800 hover:bg-transparent`}
              >
                목록
              </Button>
              <Button
                onClick={() => setViewMode("week")}
                variant="ghost" 
                size="sm"
                className={`relative z-10 flex-1 ${viewMode === "week" ? "text-black" : "text-gray-600"} hover:text-gray-800 hover:bg-transparent`}
              >
                주간
              </Button>
              <Button
                onClick={() => setViewMode("month")}
                variant="ghost"
                size="sm"
                className={`relative z-10 flex-1 ${viewMode === "month" ? "text-black" : "text-gray-600"} hover:text-gray-800 hover:bg-transparent`}
              >
                월간
              </Button>
            </div>

            {/* 팀별 필터 드롭다운 */}
            <Select
              value={selectedTeamFilter}
              onValueChange={setSelectedTeamFilter}
            >
              <SelectTrigger className="w-30">
                <SelectValue placeholder="팀 선택" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">전체 팀</SelectItem>
                {teams.map((team) => (
                  <SelectItem key={team.id} value={team.id}>
                    {team.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            {/* 구글 캘린더 드롭다운 */}
            {filteredEvents.length > 0 && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <img
                    src="https://www.gstatic.com/marketing-cms/assets/images/cf/3c/0d56042f479fac9ad22d06855578/calender.webp"
                    alt="Google Calendar"
                    className="w-8 h-8 rounded cursor-pointer hover:opacity-80 transition-opacity object-contain"
                  />
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem
                    onClick={syncEventsToGoogle}
                    disabled={isSyncing}
                  >
                    <Calendar className="mr-2 h-4 w-4" />
                    구글캘린더 동기화
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem
                    onClick={deleteConnectNextEventsFromGoogle}
                    disabled={isSyncing}
                    className="text-destructive focus:text-destructive"
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    동기화 삭제
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>

          {/* 일정 추가 버튼 */}
          {hasEditPermission && (
            <div className="flex items-center gap-2 justify-end sm:justify-start">
              {/* 장소 설정 버튼 */}
              {isMobile ? (
                <Drawer
                  open={isLocationSettingsOpen}
                  onOpenChange={setIsLocationSettingsOpen}
                >
                  <DrawerTrigger asChild>
                    <Button variant="outline" size="sm">
                      <Settings size={16} />
                    </Button>
                  </DrawerTrigger>
                  <DrawerContent className="max-h-[90vh]">
                    <DrawerHeader>
                      <DrawerTitle>장소 설정</DrawerTitle>
                    </DrawerHeader>
                    <div className="px-4 pb-4 overflow-y-auto">
                      <div className="space-y-4 py-4">
                        <div className="space-y-2">
                          <Label>새 장소 추가</Label>
                          <div className="flex gap-2">
                            <Input
                              value={newLocation}
                              onChange={(e) =>
                                setNewLocation(e.target.value)
                              }
                              placeholder="장소명을 입력하세요"
                              onKeyDown={(e) => {
                                if (e.key === "Enter") {
                                  addLocation();
                                }
                              }}
                            />
                            <Button
                              onClick={addLocation}
                              disabled={!newLocation.trim()}
                            >
                              추가
                            </Button>
                          </div>
                        </div>

                        <div className="space-y-2">
                          <Label>저장된 장소</Label>
                          <div className="max-h-40 overflow-y-auto space-y-1">
                            {savedLocations.length === 0 ? (
                              <p className="text-sm text-gray-500 py-2">
                                저장된 장소가 없습니다.
                              </p>
                            ) : (
                              savedLocations.map((location, index) => (
                                <div
                                  key={index}
                                  className="flex items-center justify-between p-2 bg-gray-50 rounded"
                                >
                                  {editingLocationIndex === index ? (
                                    <>
                                      <Input
                                        value={editingLocationValue}
                                        onChange={(e) =>
                                          setEditingLocationValue(
                                            e.target.value
                                          )
                                        }
                                        className="text-sm flex-1 mr-2"
                                        onKeyDown={(e) => {
                                          if (e.key === "Enter") {
                                            saveEditLocation();
                                          } else if (e.key === "Escape") {
                                            cancelEditLocation();
                                          }
                                        }}
                                        autoFocus
                                      />
                                      <div className="flex gap-1">
                                        <Button
                                          variant="ghost"
                                          size="sm"
                                          onClick={saveEditLocation}
                                          className="h-6 w-6 p-0 text-green-500 hover:text-green-700"
                                        >
                                          ✓
                                        </Button>
                                        <Button
                                          variant="ghost"
                                          size="sm"
                                          onClick={cancelEditLocation}
                                          className="h-6 w-6 p-0 text-gray-500 hover:text-gray-700"
                                        >
                                          ×
                                        </Button>
                                      </div>
                                    </>
                                  ) : (
                                    <>
                                      <span className="text-sm flex-1">
                                        {location}
                                      </span>
                                      <div className="flex gap-1">
                                        <Button
                                          variant="ghost"
                                          size="sm"
                                          onClick={() =>
                                            startEditLocation(
                                              index,
                                              location
                                            )
                                          }
                                          className="h-6 w-6 p-0 text-blue-500 hover:text-blue-700"
                                        >
                                          ✏
                                        </Button>
                                        <Button
                                          variant="ghost"
                                          size="sm"
                                          onClick={() =>
                                            removeLocation(location)
                                          }
                                          className="h-6 w-6 p-0 text-red-500 hover:text-red-700"
                                        >
                                          ×
                                        </Button>
                                      </div>
                                    </>
                                  )}
                                </div>
                              ))
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  </DrawerContent>
                </Drawer>
              ) : (
                <Dialog
                  open={isLocationSettingsOpen}
                  onOpenChange={setIsLocationSettingsOpen}
                >
                  <DialogTrigger asChild>
                    <Button variant="outline" size="sm">
                      <Settings size={16} />
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="w-[95vw] max-w-[425px] max-h-[90vh] overflow-y-auto mx-auto">
                    <DialogHeader>
                      <DialogTitle>장소 설정</DialogTitle>
                    </DialogHeader>
                    <div className="space-y-4 py-4">
                      <div className="space-y-2">
                        <Label>새 장소 추가</Label>
                        <div className="flex gap-2">
                          <Input
                            value={newLocation}
                            onChange={(e) =>
                              setNewLocation(e.target.value)
                            }
                            placeholder="장소명을 입력하세요"
                            onKeyDown={(e) => {
                              if (e.key === "Enter") {
                                addLocation();
                              }
                            }}
                          />
                          <Button
                            onClick={addLocation}
                            disabled={!newLocation.trim()}
                          >
                            추가
                          </Button>
                        </div>
                      </div>

                      <div className="space-y-2">
                        <Label>저장된 장소</Label>
                        <div className="max-h-40 overflow-y-auto space-y-1">
                          {savedLocations.length === 0 ? (
                            <p className="text-sm text-gray-500 py-2">
                              저장된 장소가 없습니다.
                            </p>
                          ) : (
                            savedLocations.map((location, index) => (
                              <div
                                key={index}
                                className="flex items-center justify-between p-2 bg-gray-50 rounded"
                              >
                                {editingLocationIndex === index ? (
                                  <>
                                    <Input
                                      value={editingLocationValue}
                                      onChange={(e) =>
                                        setEditingLocationValue(
                                          e.target.value
                                        )
                                      }
                                      className="text-sm flex-1 mr-2"
                                      onKeyDown={(e) => {
                                        if (e.key === "Enter") {
                                          saveEditLocation();
                                        } else if (e.key === "Escape") {
                                          cancelEditLocation();
                                        }
                                      }}
                                      autoFocus
                                    />
                                    <div className="flex gap-1">
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={saveEditLocation}
                                        className="h-6 w-6 p-0 text-green-500 hover:text-green-700"
                                      >
                                        ✓
                                      </Button>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={cancelEditLocation}
                                        className="h-6 w-6 p-0 text-gray-500 hover:text-gray-700"
                                      >
                                        ×
                                      </Button>
                                    </div>
                                  </>
                                ) : (
                                  <>
                                    <span className="text-sm flex-1">
                                      {location}
                                    </span>
                                    <div className="flex gap-1">
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={() =>
                                          startEditLocation(
                                            index,
                                            location
                                          )
                                        }
                                        className="h-6 w-6 p-0 text-blue-500 hover:text-blue-700"
                                      >
                                        ✏
                                      </Button>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={() =>
                                          removeLocation(location)
                                        }
                                        className="h-6 w-6 p-0 text-red-500 hover:text-red-700"
                                      >
                                        ×
                                      </Button>
                                    </div>
                                  </>
                                )}
                              </div>
                            ))
                          )}
                        </div>
                      </div>
                    </div>
                  </DialogContent>
                </Dialog>
              )}

              {/* 일정 추가 모달 */}
              {isMobile ? (
                <Drawer
                  open={isEventModalOpen}
                  onOpenChange={(open) => {
                    setIsEventModalOpen(open);
                    if (open && !isEditingEvent) {
                      // 모달이 열릴 때 기본 시간 설정 (현재 시간, 1시간 후) - 추가 모드만
                      const now = new Date();
                      const oneHourLater = addHours(now, 1);
                      setNewEvent({
                        title: "",
                        description: "",
                        start_date: format(now, "yyyy-MM-dd'T'HH:mm"),
                        end_date: format(
                          oneHourLater,
                          "yyyy-MM-dd'T'HH:mm"
                        ),
                        location: "",
                        program_id: programId,
                        team_id: "",
                        isRecurring: false,
                        recurringEndDate: "",
                      });
                    } else if (!open) {
                      // 모달이 닫힐 때 폼 초기화
                      setNewEvent({
                        title: "",
                        description: "",
                        start_date: "",
                        end_date: "",
                        location: "",
                        program_id: "",
                        team_id: "",
                        isRecurring: false,
                        recurringEndDate: "",
                      });
                      // 수정 모드 초기화
                      setIsEditingEvent(false);
                      setEditingEventData(null);
                    }
                  }}
                >
                  <DrawerTrigger asChild>
                    <Button
                      variant="default"
                      size="sm"
                      onClick={() => {
                        setIsEditingEvent(false);
                        setEditingEventData(null);
                        // 폼 완전 초기화
                        setNewEvent({
                          title: "",
                          description: "",
                          start_date: "",
                          end_date: "",
                          location: "",
                          program_id: "",
                          team_id: "",
                          isRecurring: false,
                          recurringEndDate: "",
                        });
                      }}
                    >
                      일정 추가
                    </Button>
                  </DrawerTrigger>
                  <DrawerContent className="max-h-[90vh]">
                    <DrawerHeader>
                      <DrawerTitle>
                        {isEditingEvent ? "일정 수정" : "새 일정 추가"}
                      </DrawerTitle>
                    </DrawerHeader>
                      <div className="grid gap-4 py-4">
                    <div className="grid gap-2">
                      <Label htmlFor="title">제목 *</Label>
                      <Input
                        id="title"
                        value={newEvent.title}
                        onChange={(e) =>
                          setNewEvent((prev) => ({
                            ...prev,
                            title: e.target.value,
                          }))
                        }
                        placeholder="일정 제목을 입력하세요"
                      />
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="description">설명</Label>
                      <Textarea
                        id="description"
                        value={newEvent.description}
                        onChange={(e) =>
                          setNewEvent((prev) => ({
                            ...prev,
                            description: e.target.value,
                          }))
                        }
                        placeholder="일정 설명을 입력하세요"
                        rows={3}
                      />
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="start_date">시작 일시 *</Label>
                      <Input
                        id="start_date"
                        type="datetime-local"
                        value={newEvent.start_date}
                        onChange={(e) => {
                          const startDateTime = e.target.value;
                          // 시작 일시가 변경되면 자동으로 종료 일시를 1시간 후로 설정
                          let endDateTime = "";
                          if (startDateTime) {
                            const startDate = new Date(startDateTime);
                            const endDate = addHours(startDate, 1);
                            endDateTime = format(
                              endDate,
                              "yyyy-MM-dd'T'HH:mm"
                            );
                          }

                          setNewEvent((prev) => ({
                            ...prev,
                            start_date: startDateTime,
                            end_date: endDateTime,
                          }));
                        }}
                      />
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="end_date">종료 일시</Label>
                      <Input
                        id="end_date"
                        type="datetime-local"
                        value={newEvent.end_date}
                        onChange={(e) =>
                          setNewEvent((prev) => ({
                            ...prev,
                            end_date: e.target.value,
                          }))
                        }
                      />
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="location">장소</Label>
                      <Select
                        value={newEvent.location}
                        onValueChange={(value) => {
                          if (value === "custom") {
                            // Custom option selected, clear the location to show input
                            setNewEvent((prev) => ({
                              ...prev,
                              location: "",
                            }));
                          } else {
                            // Pre-saved location selected
                            setNewEvent((prev) => ({
                              ...prev,
                              location: value,
                            }));
                          }
                        }}
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="장소를 선택하거나 직접 입력하세요" />
                        </SelectTrigger>
                        <SelectContent>
                          {savedLocations.map((location) => (
                            <SelectItem key={location} value={location}>
                              {location}
                            </SelectItem>
                          ))}
                          <SelectItem value="custom">
                            직접 입력
                          </SelectItem>
                        </SelectContent>
                      </Select>

                      {/* Show input field when custom is selected or when location is not in saved locations */}
                      {(newEvent.location === "" ||
                        !savedLocations.includes(
                          newEvent.location
                        )) && (
                        <Input
                          id="location-custom"
                          value={newEvent.location}
                          onChange={(e) =>
                            setNewEvent((prev) => ({
                              ...prev,
                              location: e.target.value,
                            }))
                          }
                          placeholder="장소를 입력하세요"
                          className="mt-2"
                        />
                      )}
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="team">진행팀</Label>
                      <Select
                        value={newEvent.team_id}
                        onValueChange={(value) =>
                          setNewEvent((prev) => ({
                            ...prev,
                            team_id: value === "none" ? "" : value,
                          }))
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="진행팀을 선택하세요" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="none">팀 없음</SelectItem>
                          {teams.map((team) => (
                            <SelectItem key={team.id} value={team.id}>
                              {team.name}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>

                    {/* 반복 설정 */}
                    <div className="grid gap-3 pt-4 border-t">
                      <div className="flex items-center justify-between">
                        <Label
                          htmlFor="recurring"
                          className="text-sm font-medium"
                        >
                          매주 반복
                        </Label>
                        <Switch
                          id="recurring"
                          checked={newEvent.isRecurring}
                          onCheckedChange={(checked) =>
                            setNewEvent((prev) => ({
                              ...prev,
                              isRecurring: checked,
                              recurringEndDate: checked
                                ? prev.recurringEndDate
                                : "",
                            }))
                          }
                        />
                      </div>

                      {newEvent.isRecurring && (
                        <div className="grid gap-3 pl-6 space-y-2">
                          <div className="grid gap-2">
                            <Label htmlFor="recurring-end">
                              반복 종료일
                            </Label>
                            <Input
                              id="recurring-end"
                              type="date"
                              value={newEvent.recurringEndDate}
                              onChange={(e) =>
                                setNewEvent((prev) => ({
                                  ...prev,
                                  recurringEndDate: e.target.value,
                                }))
                              }
                              min={
                                newEvent.start_date
                                  ? new Date(newEvent.start_date)
                                      .toISOString()
                                      .split("T")[0]
                                  : new Date()
                                      .toISOString()
                                      .split("T")[0]
                              }
                            />
                          </div>

                          <div className="text-xs text-gray-600 bg-blue-50 p-2 rounded">
                            💡 위에 설정한 시작일부터 종료일까지 매주
                            같은 요일, 같은 시간에 반복됩니다.
                            <br />
                            예: 월요일 오전 10시~오후 12시 → 매주 월요일
                            오전 10시~오후 12시 반복
                          </div>
                        </div>
                      )}
                    </div>
                      </div>
                      <div className="flex justify-end gap-2 mt-4">
                        <Button
                          variant="outline"
                          onClick={() => setIsEventModalOpen(false)}
                        >
                          취소
                        </Button>
                        <Button onClick={handleSaveEvent}>
                          {isEditingEvent ? "수정" : "추가"}
                        </Button>
                      </div>
                    </div>
                  </DrawerContent>
                </Drawer>
              ) : (
                <Dialog
                  open={isEventModalOpen}
                  onOpenChange={(open) => {
                    setIsEventModalOpen(open);
                    if (open && !isEditingEvent) {
                      // 모달이 열릴 때 기본 시간 설정 (현재 시간, 1시간 후) - 추가 모드만
                      const now = new Date();
                      const oneHourLater = addHours(now, 1);
                      setNewEvent({
                        title: "",
                        description: "",
                        start_date: format(now, "yyyy-MM-dd'T'HH:mm"),
                        end_date: format(
                          oneHourLater,
                          "yyyy-MM-dd'T'HH:mm"
                        ),
                        location: "",
                        program_id: programId,
                        team_id: "",
                        isRecurring: false,
                        recurringEndDate: "",
                      });
                    } else if (!open) {
                      // 모달이 닫힐 때 폼 초기화
                      setNewEvent({
                        title: "",
                        description: "",
                        start_date: "",
                        end_date: "",
                        location: "",
                        program_id: "",
                        team_id: "",
                        isRecurring: false,
                        recurringEndDate: "",
                      });
                      // 수정 모드 초기화
                      setIsEditingEvent(false);
                      setEditingEventData(null);
                    }
                  }}
                >
                  <DialogTrigger asChild>
                    <Button
                      variant="default"
                      size="sm"
                      onClick={() => {
                        setIsEditingEvent(false);
                        setEditingEventData(null);
                        // 폼 완전 초기화
                        setNewEvent({
                          title: "",
                          description: "",
                          start_date: "",
                          end_date: "",
                          location: "",
                          program_id: "",
                          team_id: "",
                          isRecurring: false,
                          recurringEndDate: "",
                        });
                      }}
                    >
                      일정 추가
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="w-[95vw] max-w-[425px] max-h-[90vh] overflow-y-auto mx-auto">
                    <DialogHeader>
                      <DialogTitle>
                        {isEditingEvent ? "일정 수정" : "새 일정 추가"}
                      </DialogTitle>
                    </DialogHeader>
                    <div className="grid gap-4 py-4">
                      <div className="grid gap-2">
                        <Label htmlFor="title">제목 *</Label>
                        <Input
                          id="title"
                          value={newEvent.title}
                          onChange={(e) =>
                            setNewEvent((prev) => ({
                              ...prev,
                              title: e.target.value,
                            }))
                          }
                          placeholder="일정 제목을 입력하세요"
                        />
                      </div>

                      <div className="grid gap-2">
                        <Label htmlFor="description">설명</Label>
                        <Textarea
                          id="description"
                          value={newEvent.description}
                          onChange={(e) =>
                            setNewEvent((prev) => ({
                              ...prev,
                              description: e.target.value,
                            }))
                          }
                          placeholder="일정 설명을 입력하세요"
                          rows={3}
                        />
                      </div>

                      <div className="grid gap-2">
                        <Label htmlFor="start_date">시작 일시 *</Label>
                        <Input
                          id="start_date"
                          type="datetime-local"
                          value={newEvent.start_date}
                          onChange={(e) => {
                            const startDateTime = e.target.value;
                            // 시작 일시가 변경되면 자동으로 종료 일시를 1시간 후로 설정
                            let endDateTime = "";
                            if (startDateTime) {
                              const startDate = new Date(startDateTime);
                              const endDate = addHours(startDate, 1);
                              endDateTime = format(
                                endDate,
                                "yyyy-MM-dd'T'HH:mm"
                              );
                            }

                            setNewEvent((prev) => ({
                              ...prev,
                              start_date: startDateTime,
                              end_date: endDateTime,
                            }));
                          }}
                        />
                      </div>

                      <div className="grid gap-2">
                        <Label htmlFor="end_date">종료 일시</Label>
                        <Input
                          id="end_date"
                          type="datetime-local"
                          value={newEvent.end_date}
                          onChange={(e) =>
                            setNewEvent((prev) => ({
                              ...prev,
                              end_date: e.target.value,
                            }))
                          }
                        />
                      </div>

                      <div className="grid gap-2">
                        <Label htmlFor="location">장소</Label>
                        <Select
                          value={newEvent.location}
                          onValueChange={(value) => {
                            if (value === "custom") {
                              // Custom option selected, clear the location to show input
                              setNewEvent((prev) => ({
                                ...prev,
                                location: "",
                              }));
                            } else {
                              // Pre-saved location selected
                              setNewEvent((prev) => ({
                                ...prev,
                                location: value,
                              }));
                            }
                          }}
                        >
                          <SelectTrigger>
                            <SelectValue placeholder="장소를 선택하거나 직접 입력하세요" />
                          </SelectTrigger>
                          <SelectContent>
                            {savedLocations.map((location) => (
                              <SelectItem key={location} value={location}>
                                {location}
                              </SelectItem>
                            ))}
                            <SelectItem value="custom">
                              직접 입력
                            </SelectItem>
                          </SelectContent>
                        </Select>

                        {/* Show input field when custom is selected or when location is not in saved locations */}
                        {(newEvent.location === "" ||
                          !savedLocations.includes(
                            newEvent.location
                          )) && (
                          <Input
                            id="location-custom"
                            value={newEvent.location}
                            onChange={(e) =>
                              setNewEvent((prev) => ({
                                ...prev,
                                location: e.target.value,
                              }))
                            }
                            placeholder="장소를 입력하세요"
                            className="mt-2"
                          />
                        )}
                      </div>

                      <div className="grid gap-2">
                        <Label htmlFor="team">진행팀</Label>
                        <Select
                          value={newEvent.team_id}
                          onValueChange={(value) =>
                            setNewEvent((prev) => ({
                              ...prev,
                              team_id: value === "none" ? "" : value,
                            }))
                          }
                        >
                          <SelectTrigger>
                            <SelectValue placeholder="진행팀을 선택하세요" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="none">팀 없음</SelectItem>
                            {teams.map((team) => (
                              <SelectItem key={team.id} value={team.id}>
                                {team.name}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>

                      {/* 반복 설정 */}
                      <div className="grid gap-3 pt-4 border-t">
                        <div className="flex items-center justify-between">
                          <Label
                            htmlFor="recurring"
                            className="text-sm font-medium"
                          >
                            매주 반복
                          </Label>
                          <Switch
                            id="recurring"
                            checked={newEvent.isRecurring}
                            onCheckedChange={(checked) =>
                              setNewEvent((prev) => ({
                                ...prev,
                                isRecurring: checked,
                                recurringEndDate: checked
                                  ? prev.recurringEndDate
                                  : "",
                              }))
                            }
                          />
                        </div>

                        {newEvent.isRecurring && (
                          <div className="grid gap-3 pl-6 space-y-2">
                            <div className="grid gap-2">
                              <Label htmlFor="recurring-end">
                                반복 종료일
                              </Label>
                              <Input
                                id="recurring-end"
                                type="date"
                                value={newEvent.recurringEndDate}
                                onChange={(e) =>
                                  setNewEvent((prev) => ({
                                    ...prev,
                                    recurringEndDate: e.target.value,
                                  }))
                                }
                                min={
                                  newEvent.start_date
                                    ? new Date(newEvent.start_date)
                                        .toISOString()
                                        .split("T")[0]
                                    : new Date()
                                        .toISOString()
                                        .split("T")[0]
                                }
                              />
                            </div>

                            <div className="text-xs text-gray-600 bg-blue-50 p-2 rounded">
                              💡 위에 설정한 시작일부터 종료일까지 매주
                              같은 요일, 같은 시간에 반복됩니다.
                              <br />
                              예: 월요일 오전 10시~오후 12시 → 매주 월요일
                              오전 10시~오후 12시 반복
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="outline"
                        onClick={() => setIsEventModalOpen(false)}
                      >
                        취소
                      </Button>
                      <Button onClick={handleSaveEvent}>
                        {isEditingEvent ? "수정" : "추가"}
                      </Button>
                    </div>
                  </DialogContent>
                </Dialog>
              )}
            </div>
          )}
        </div>

        {/* 팀 필터 */}
        {/* <div className="flex flex-wrap gap-2">
          <Button
            onClick={() => setSelectedTeamFilter("all")}
            variant={
              selectedTeamFilter === "all" ? "default" : "secondary"
            }
            size="sm"
            className="rounded-full"
          >
            전체
          </Button>
          {teams.map((team) => (
            <Button
              key={team.id}
              onClick={() => setSelectedTeamFilter(team.id)}
              variant={
                selectedTeamFilter === team.id ? "default" : "secondary"
              }
              size="sm"
              className="rounded-full"
            >
              {team.name}
            </Button>
          ))}
          {teams.length === 0 && (
            <span className="text-sm text-gray-500">
              등록된 팀이 없습니다
            </span>
          )}
        </div> */}

        {/* 일정 상세보기 모달 */}
        {isMobile ? (
          <Drawer
            open={isEventDetailModalOpen}
            onOpenChange={setIsEventDetailModalOpen}
          >
            <DrawerContent className="max-h-[90vh]">
              <DrawerHeader>
                <DrawerTitle>일정 상세보기</DrawerTitle>
              </DrawerHeader>
              <div className="px-4 pb-4 overflow-y-auto">
                {selectedEvent && (
                  <div className="space-y-4 py-4">
                    <div className="space-y-2">
                      <h3 className="text-lg font-semibold">
                        {selectedEvent?.title}
                      </h3>
                      {selectedEvent?.description && (
                        <p className="text-gray-600">
                          {selectedEvent.description}
                        </p>
                      )}
                    </div>

                    <div className="space-y-3">
                      <div className="flex items-center gap-2">
                        <Calendar size={16} className="text-gray-500" />
                        <span className="text-sm">
                          일시:{" "}
                          {selectedEvent?.start_date && (() => {
                            const startDate = parseISO(selectedEvent.start_date);
                            return formatFullDateTimeToKorean(startDate, ko);
                          })()}
                          {selectedEvent?.end_date &&
                            ` - ${formatDateTimeToKorean(parseISO(selectedEvent.end_date))}`}
                        </span>
                      </div>

                      <div className="flex items-center gap-2">
                        <MapPin size={16} className="text-gray-500" />
                        <span className="text-sm">
                          장소: {selectedEvent?.location || "미정"}
                        </span>
                      </div>

                      <div className="flex items-center gap-2">
                        <Users size={16} className="text-gray-500" />
                        <span className="text-sm">
                          팀:{" "}
                          {selectedEvent?.team_id
                            ? teams.find(
                                (t) => t.id === selectedEvent?.team_id
                              )?.name
                            : "팀 없음"}
                        </span>
                      </div>
                    </div>

                    <div className="pt-4 border-t">
                      <div className="text-xs text-gray-500">
                        프로그램:{" "}
                        {programs.find(
                          (p) => p.id === selectedEvent?.program_id
                        )?.name || "알 수 없음"}
                      </div>
                    </div>
                  </div>
                )}
                <div className="flex justify-end gap-2 mt-4">
                  <Button
                    variant="outline"
                    onClick={() => setIsEventDetailModalOpen(false)}
                  >
                    닫기
                  </Button>
                  {/* 삭제 버튼 - 권한 기반으로 표시 */}
                  {hasEditPermission && selectedEvent && (
                    <Button
                      variant="destructive"
                      onClick={() => selectedEvent && handleDeleteEvent(selectedEvent.id)}
                    >
                      삭제
                    </Button>
                  )}
                  {/* 수정 버튼 - 권한 기반으로 표시 */}
                  {hasEditPermission && (
                    <Button
                      onClick={() => {
                        if (selectedEvent) {
                          setEditingEventData(selectedEvent);
                          setNewEvent({
                            title: selectedEvent.title || "",
                            description: selectedEvent.description || "",
                            start_date: selectedEvent.start_date
                              ? format(
                                  parseISO(selectedEvent.start_date),
                                  "yyyy-MM-dd'T'HH:mm"
                                )
                              : "",
                            end_date: selectedEvent.end_date
                              ? format(
                                  parseISO(selectedEvent.end_date),
                                  "yyyy-MM-dd'T'HH:mm"
                                )
                              : "",
                            location: selectedEvent.location || "",
                            program_id: selectedEvent.program_id || "",
                            team_id: selectedEvent.team_id || "",
                            isRecurring:
                              selectedEvent.is_recurring || false,
                            recurringEndDate:
                              selectedEvent.recurring_end_date || "",
                          });
                          setIsEditingEvent(true);
                          setIsEventDetailModalOpen(false);
                          setIsEventModalOpen(true);
                        }
                      }}
                    >
                      수정
                    </Button>
                  )}
                </div>
              </div>
            </DrawerContent>
          </Drawer>
        ) : (
          <Dialog
            open={isEventDetailModalOpen}
            onOpenChange={setIsEventDetailModalOpen}
          >
            <DialogContent className="w-[95vw] max-w-[500px] max-h-[90vh] overflow-y-auto mx-auto">
            <DialogHeader>
              <DialogTitle>일정 상세보기</DialogTitle>
            </DialogHeader>
            {selectedEvent && (
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <h3 className="text-lg font-semibold">
                    {selectedEvent?.title}
                  </h3>
                  {selectedEvent?.description && (
                    <p className="text-gray-600">
                      {selectedEvent.description}
                    </p>
                  )}
                </div>

                <div className="space-y-3">
                  <div className="flex items-center gap-2">
                    <Calendar size={16} className="text-gray-500" />
                    <span className="text-sm">
                      일시:{" "}
                      {selectedEvent?.start_date && (() => {
                        const startDate = parseISO(selectedEvent.start_date);
                        return formatFullDateTimeToKorean(startDate, ko);
                      })()}
                      {selectedEvent?.end_date &&
                        ` - ${formatDateTimeToKorean(parseISO(selectedEvent.end_date))}`}
                    </span>
                  </div>

                  <div className="flex items-center gap-2">
                    <MapPin size={16} className="text-gray-500" />
                    <span className="text-sm">
                      장소: {selectedEvent?.location || "미정"}
                    </span>
                  </div>

                  <div className="flex items-center gap-2">
                    <Users size={16} className="text-gray-500" />
                    <span className="text-sm">
                      팀:{" "}
                      {selectedEvent?.team_id
                        ? teams.find(
                            (t) => t.id === selectedEvent?.team_id
                          )?.name
                        : "팀 없음"}
                    </span>
                  </div>
                </div>

                <div className="pt-4 border-t">
                  <div className="text-xs text-gray-500">
                    프로그램:{" "}
                    {programs.find(
                      (p) => p.id === selectedEvent?.program_id
                    )?.name || "알 수 없음"}
                  </div>
                </div>
              </div>
            )}
            <div className="flex justify-end gap-2">
              <Button
                variant="outline"
                onClick={() => setIsEventDetailModalOpen(false)}
              >
                닫기
              </Button>
              {/* 삭제 버튼 - 권한 기반으로 표시 */}
              {hasEditPermission && selectedEvent && (
                <Button
                  variant="destructive"
                  onClick={() => selectedEvent && handleDeleteEvent(selectedEvent.id)}
                >
                  삭제
                </Button>
              )}
              {/* 수정 버튼 - 권한 기반으로 표시 */}
              {hasEditPermission && (
                <Button
                  onClick={() => {
                    if (selectedEvent) {
                      setEditingEventData(selectedEvent);
                      setNewEvent({
                        title: selectedEvent.title || "",
                        description: selectedEvent.description || "",
                        start_date: selectedEvent.start_date
                          ? format(
                              parseISO(selectedEvent.start_date),
                              "yyyy-MM-dd'T'HH:mm"
                            )
                          : "",
                        end_date: selectedEvent.end_date
                          ? format(
                              parseISO(selectedEvent.end_date),
                              "yyyy-MM-dd'T'HH:mm"
                            )
                          : "",
                        location: selectedEvent.location || "",
                        program_id: selectedEvent.program_id || "",
                        team_id: selectedEvent.team_id || "",
                        isRecurring:
                          selectedEvent.is_recurring || false,
                        recurringEndDate:
                          selectedEvent.recurring_end_date || "",
                      });
                      setIsEditingEvent(true);
                      setIsEventDetailModalOpen(false);
                      setIsEventModalOpen(true);
                    }
                  }}
                >
                  수정
                </Button>
              )}
            </div>
            </DialogContent>
          </Dialog>
        )}

        {/* 날짜별 일정 보기 모달 */}
        {isMobile ? (
          <Drawer
            open={isDayEventsModalOpen}
            onOpenChange={setIsDayEventsModalOpen}
          >
            <DrawerContent className="max-h-[90vh]">
              <DrawerHeader>
                <DrawerTitle>
                  {selectedDate && (
                    <>
                      {format(selectedDate, "yyyy년 M월 d일 (EEE)", {
                        locale: ko,
                      })}
                      의 일정
                    </>
                  )}
                </DrawerTitle>
              </DrawerHeader>
                <div className="max-h-[60vh] overflow-y-auto">
              {selectedDateEvents.length > 0 ? (
                <div className="space-y-3">
                  {selectedDateEvents
                    .sort(
                      (a, b) =>
                        new Date(a.start_date).getTime() -
                        new Date(b.start_date).getTime()
                    )
                    .map((event) => {
                      const program = programs.find(
                        (p) => p.id === event.program_id
                      );
                      const team = teams.find(
                        (t) => t.id === event.team_id
                      );
                      const eventDate = parseISO(event.start_date);
                      const endDate = event.end_date
                        ? parseISO(event.end_date)
                        : null;
                      const timeStatus = getEventTimeStatus(
                        eventDate,
                        endDate
                      );

                      return (
                        <div
                          key={event.id}
                          className={`border rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer ${
                            timeStatus.status === "past"
                              ? "opacity-75"
                              : ""
                          }`}
                          onClick={() => {
                            setSelectedEvent(event);
                            setIsEventDetailModalOpen(true);
                            setIsDayEventsModalOpen(false);
                          }}
                        >
                          <div className="flex justify-between items-start">
                            <div className="flex-1">
                              <div className="flex items-start gap-2 mb-2">
                                <h3
                                  className={`font-semibold flex-1 ${timeStatus.status === "past" ? "text-gray-600" : ""}`}
                                >
                                  {event.title}
                                </h3>
                                <div className="flex gap-2 flex-shrink-0">
                                  <span
                                    className={`text-xs px-2 py-1 rounded-full font-medium whitespace-nowrap ${timeStatus.bgColor} ${timeStatus.color}`}
                                  >
                                    {timeStatus.icon} {timeStatus.label}
                                  </span>
                                  {team && (
                                    <span
                                      className="text-xs px-2 py-1 rounded border whitespace-nowrap"
                                      style={getTeamStyle(event.team_id)}
                                    >
                                      {team.name}
                                    </span>
                                  )}
                                </div>
                              </div>
                              <div className="space-y-2">
                                <div className="flex items-center gap-1">
                                  <Clock
                                    size={16}
                                    className="text-gray-600"
                                  />
                                  <span className="font-medium text-sm">
                                    {formatDateTimeToKorean(eventDate)}
                                    {endDate &&
                                      ` - ${formatDateTimeToKorean(endDate)}`}
                                  </span>
                                </div>
                                {event.location && (
                                  <div className="flex items-center gap-1">
                                    <MapPin
                                      size={16}
                                      className="text-gray-600"
                                    />
                                    <span className="font-medium text-sm">
                                      {event.location}
                                    </span>
                                  </div>
                                )}
                                {event.description && (
                                  <p className="text-gray-500 text-sm mt-2">
                                    {event.description}
                                  </p>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                </div>
              ) : (
                <div className="text-center py-8 text-gray-500">
                  이 날짜에는 등록된 일정이 없습니다.
                </div>
              )}
                </div>
                <div className="flex justify-between mt-4">
                  {hasEditPermission && (
                    <Button
                      onClick={() => {
                        // 선택된 날짜의 현재 시간으로 설정
                        if (selectedDate) {
                          const now = new Date();
                          const selectedDateTime = new Date(selectedDate);

                          // 선택된 날짜에 현재 시간 적용
                          selectedDateTime.setHours(now.getHours());
                          selectedDateTime.setMinutes(now.getMinutes());

                          const oneHourLater = addHours(
                            selectedDateTime,
                            1
                          );

                          setNewEvent({
                            title: "",
                            description: "",
                            start_date: format(
                              selectedDateTime,
                              "yyyy-MM-dd'T'HH:mm"
                            ),
                            end_date: format(
                              oneHourLater,
                              "yyyy-MM-dd'T'HH:mm"
                            ),
                            location: "",
                            program_id: programId,
                            team_id: "",
                            isRecurring: false,
                            recurringEndDate: "",
                          });

                          setIsEditingEvent(false);
                          setEditingEventData(null);
                          setIsDayEventsModalOpen(false);
                          setIsEventModalOpen(true);
                        }
                      }}
                    >
                      일정 추가
                    </Button>
                  )}
                  <Button
                    variant="outline"
                    onClick={() => setIsDayEventsModalOpen(false)}
                  >
                    닫기
                  </Button>
                </div>
              </div>
            </DrawerContent>
          </Drawer>
        ) : (
          <Dialog
            open={isDayEventsModalOpen}
            onOpenChange={setIsDayEventsModalOpen}
          >
            <DialogContent className="w-[95vw] max-w-[600px] max-h-[90vh] overflow-y-auto mx-auto">
              <DialogHeader>
                <DialogTitle>
                  {selectedDate && (
                    <>
                      {format(selectedDate, "yyyy년 M월 d일 (EEE)", {
                        locale: ko,
                      })}
                      의 일정
                    </>
                  )}
                </DialogTitle>
              </DialogHeader>
              <div className="max-h-[60vh] overflow-y-auto">
                {selectedDateEvents.length > 0 ? (
                  <div className="space-y-3">
                    {selectedDateEvents
                      .sort(
                        (a, b) =>
                          new Date(a.start_date).getTime() -
                          new Date(b.start_date).getTime()
                      )
                      .map((event) => {
                        const program = programs.find(
                          (p) => p.id === event.program_id
                        );
                        const team = teams.find(
                          (t) => t.id === event.team_id
                        );
                        const eventDate = parseISO(event.start_date);
                        const endDate = event.end_date
                          ? parseISO(event.end_date)
                          : null;
                        const timeStatus = getEventTimeStatus(
                          eventDate,
                          endDate
                        );

                        return (
                          <div
                            key={event.id}
                            className={`border rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer ${
                              timeStatus.status === "past"
                                ? "opacity-75"
                                : ""
                            }`}
                            onClick={() => {
                              setSelectedEvent(event);
                              setIsEventDetailModalOpen(true);
                              setIsDayEventsModalOpen(false);
                            }}
                          >
                            <div className="flex justify-between items-start">
                              <div className="flex-1">
                                <div className="flex items-start gap-2 mb-2">
                                  <h3
                                    className={`font-semibold flex-1 ${timeStatus.status === "past" ? "text-gray-600" : ""}`}
                                  >
                                    {event.title}
                                  </h3>
                                  <div className="flex gap-2 flex-shrink-0">
                                    <span
                                      className={`text-xs px-2 py-1 rounded-full font-medium whitespace-nowrap ${timeStatus.bgColor} ${timeStatus.color}`}
                                    >
                                      {timeStatus.icon} {timeStatus.label}
                                    </span>
                                    {team && (
                                      <span
                                        className="text-xs px-2 py-1 rounded border whitespace-nowrap"
                                        style={getTeamStyle(event.team_id)}
                                      >
                                        {team.name}
                                      </span>
                                    )}
                                  </div>
                                </div>
                                <div className="space-y-2">
                                  <div className="flex items-center gap-1">
                                    <Clock
                                      size={16}
                                      className="text-gray-600"
                                    />
                                    <span className="font-medium text-sm">
                                      {formatDateTimeToKorean(eventDate)}
                                      {endDate &&
                                        ` - ${formatDateTimeToKorean(endDate)}`}
                                    </span>
                                  </div>
                                  {event.location && (
                                    <div className="flex items-center gap-1">
                                      <MapPin
                                        size={16}
                                        className="text-gray-600"
                                      />
                                      <span className="font-medium text-sm">
                                        {event.location}
                                      </span>
                                    </div>
                                  )}
                                  {event.description && (
                                    <p className="text-gray-500 text-sm mt-2">
                                      {event.description}
                                    </p>
                                  )}
                                </div>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                  </div>
                ) : (
                  <div className="text-center py-8 text-gray-500">
                    이 날짜에는 등록된 일정이 없습니다.
                  </div>
                )}
              </div>
              <div className="flex justify-between">
                {hasEditPermission && (
                  <Button
                    onClick={() => {
                      // 선택된 날짜의 현재 시간으로 설정
                      if (selectedDate) {
                        const now = new Date();
                        const selectedDateTime = new Date(selectedDate);

                        // 선택된 날짜에 현재 시간 적용
                        selectedDateTime.setHours(now.getHours());
                        selectedDateTime.setMinutes(now.getMinutes());

                        const oneHourLater = addHours(
                          selectedDateTime,
                          1
                        );

                        setNewEvent({
                          title: "",
                          description: "",
                          start_date: format(
                            selectedDateTime,
                            "yyyy-MM-dd'T'HH:mm"
                          ),
                          end_date: format(
                            oneHourLater,
                            "yyyy-MM-dd'T'HH:mm"
                          ),
                          location: "",
                          program_id: programId,
                          team_id: "",
                          isRecurring: false,
                          recurringEndDate: "",
                        });

                        setIsEditingEvent(false);
                        setEditingEventData(null);
                        setIsDayEventsModalOpen(false);
                        setIsEventModalOpen(true);
                      }
                    }}
                  >
                    일정 추가
                  </Button>
                )}
                <Button
                  variant="outline"
                  onClick={() => setIsDayEventsModalOpen(false)}
                >
                  닫기
                </Button>
              </div>
            </DialogContent>
          </Dialog>
        )}

        {/* 날짜 네비게이션 */}
        {viewMode !== "list" && (
          <div className="flex justify-between items-center">
            <Button
              variant="outline"
              size="sm"
              onClick={() => navigateDate("prev")}
            >
              <ChevronLeft size={16} />
            </Button>

            <h3 className="text-lg font-semibold">
              {viewMode === "month"
                ? format(currentDate, "yyyy년 M월", { locale: ko })
                : `${format(weekDays[0], "M월 d일", { locale: ko })} - ${format(weekDays[6], "M월 d일", { locale: ko })}`}
            </h3>

            <Button
              variant="outline"
              size="sm"
              onClick={() => navigateDate("next")}
            >
              <ChevronRight size={16} />
            </Button>
          </div>
        )}
      </div>

      <div className="px-2 pb-4">
        {/* 목록 보기 */}
        {viewMode === "list" && (
          <div className="space-y-6">
            {(() => {
              // 일정을 시간대별로 그룹핑
              const groupedEvents = filteredEvents
                .sort(
                  (a, b) =>
                    new Date(a.start_date).getTime() -
                    new Date(b.start_date).getTime()
                )
                .reduce(
                  (groups, event) => {
                    const eventDate = parseISO(event.start_date);
                    const endDate = event.end_date
                      ? parseISO(event.end_date)
                      : null;
                    const timeStatus = getEventTimeStatus(
                      eventDate,
                      endDate
                    );

                    if (!groups[timeStatus.status]) {
                      groups[timeStatus.status] = [];
                    }
                    groups[timeStatus.status].push(event);
                    return groups;
                  },
                  {} as Record<string, typeof filteredEvents>
                );

              // 정렬 순서 정의
              const statusOrder = [
                "ongoing",
                "today",
                "upcoming",
                "past",
              ];

              return statusOrder.map((status) => {
                const events = groupedEvents[status];
                if (!events || events.length === 0) return null;

                const statusInfo = {
                  ongoing: {
                    label: "진행중인 일정",
                    icon: "",
                    color: "text-green-700",
                  },
                  today: {
                    label: "오늘 일정",
                    icon: "",
                    color: "text-blue-700",
                  },
                  upcoming: {
                    label: "다가오는 일정",
                    icon: "",
                    color: "text-orange-700",
                  },
                  past: {
                    label: "지난 일정",
                    icon: "",
                    color: "text-gray-500",
                  },
                }[status];

                return (
                  <div key={status} className="space-y-3">
                    <div className="flex items-center gap-2 pb-2 border-b">
                      <span className="text-lg">
                        {statusInfo?.icon}
                      </span>
                      <h4
                        className={`font-semibold text-sm ${statusInfo?.color}`}
                      >
                        {statusInfo?.label} ({events.length})
                      </h4>
                    </div>
                    <div className="space-y-3">
                      {events.map((event) => {
                        const program = programs.find(
                          (p) => p.id === event.program_id
                        );
                        const team = teams.find(
                          (t) => t.id === event.team_id
                        );
                        const eventDate = parseISO(event.start_date);
                        const endDate = event.end_date
                          ? parseISO(event.end_date)
                          : null;
                        const timeStatus = getEventTimeStatus(
                          eventDate,
                          endDate
                        );

                        return (
                          <div
                            key={event.id}
                            className={`border rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer ${
                              timeStatus.status === "past"
                                ? "opacity-75"
                                : ""
                            }`}
                            onClick={() => {
                              setSelectedEvent(event);
                              setIsEventDetailModalOpen(true);
                            }}
                          >
                            <div className="flex justify-between items-start">
                              <div className="flex-1">
                                <div className="flex items-start gap-2 mb-2">
                                  <h3
                                    className={`font-semibold flex-1 leading-tight ${timeStatus.status === "past" ? "text-gray-600" : ""}`}
                                  >
                                    {event.title}
                                  </h3>
                                  <div className="flex gap-2 flex-shrink-0">
                                    <span
                                      className={`text-xs px-2 py-1 rounded-full font-medium ${timeStatus.bgColor} ${timeStatus.color}`}
                                    >
                                      {timeStatus.icon}{" "}
                                      {timeStatus.label}
                                    </span>
                                    {team && (
                                      <span
                                        className="text-xs px-2 py-1 rounded border font-medium"
                                        style={getTeamStyle(
                                          event.team_id
                                        )}
                                      >
                                        {team.name}
                                      </span>
                                    )}
                                  </div>
                                </div>
                                <div className="space-y-2">
                                  <div className="flex items-center gap-1">
                                    <Calendar
                                      size={16}
                                      className="text-gray-600"
                                    />
                                    <span className="font-medium text-sm">
                                      {format(
                                        eventDate,
                                        "yyyy년 M월 d일 (EEE)",
                                        { locale: ko }
                                      )} {formatDateTimeToKorean(eventDate)}
                                      {endDate &&
                                        ` - ${formatDateTimeToKorean(endDate)}`}
                                    </span>
                                  </div>
                                  {event.location && (
                                    <div className="flex items-center gap-1">
                                      <MapPin
                                        size={16}
                                        className="text-gray-600"
                                      />
                                      <span className="font-medium text-sm">
                                        {event.location}
                                      </span>
                                    </div>
                                  )}
                                  {event.description && (
                                    <p className="text-gray-500 text-sm mt-2">
                                      {event.description}
                                    </p>
                                  )}
                                </div>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              });
            })()}
            {filteredEvents.length === 0 && (
              <div className="text-center py-8 text-gray-500">
                등록된 일정이 없습니다.
              </div>
            )}
          </div>
        )}

        {/* 주간 보기 */}
        {viewMode === "week" && (
          <div>
            {/* 요일 헤더 */}
            <div
              className="grid border-b"
              style={{ gridTemplateColumns: "60px repeat(7, 1fr)" }}
            >
              <div className="p-1 text-center text-xs font-medium text-gray-500 border-r">
              </div>
              {weekDays.map((day, index) => (
                <div
                  key={day.toISOString()}
                  className={`p-2 text-center border-l ${
                    isSameDay(day, new Date()) ? "bg-blue-50" : ""
                  }`}
                >
                  <div
                    className={`text-xs font-medium ${
                      index === 0
                        ? "text-red-600"
                        : index === 6
                          ? "text-blue-600"
                          : "text-gray-500"
                    }`}
                  >
                    {format(day, "EEE", { locale: ko })}
                  </div>
                  <div className="text-sm font-medium">
                    {format(day, "d")}
                  </div>
                </div>
              ))}
            </div>

            {/* 시간별 그리드 */}
            <div className="relative">
              {Array.from({ length: 24 }, (_, hour) => (
                <div
                  key={hour}
                  className="grid border-b"
                  style={{
                    height: "70px",
                    gridTemplateColumns: "60px repeat(7, 1fr)",
                  }}
                >
                  <div className="text-xs text-gray-500 border-r border-b-0 flex items-center justify-center relative bg-white" style={{ height: "70px" }}>
                    <div className="absolute" style={{ top: "-10px" }}>
                      {hour === 0 ? "" : formatHourToKorean(hour)}
                    </div>
                  </div>
                  {weekDays.map((day, dayIndex) => (
                    <div 
                      key={dayIndex} 
                      className="border-l cursor-pointer hover:bg-gray-50 transition-colors"
                      onClick={() => handleDateClick(day)}
                    ></div>
                  ))}
                </div>
              ))}

              {/* 이벤트 표시 */}
              {weekDays.map((day, dayIndex) => {
                const dayEvents = getEventsForDay(day);

                return dayEvents.map((event) => {
                  const startTime = parseISO(event.start_date);
                  const endTime = event.end_date
                    ? parseISO(event.end_date)
                    : new Date(startTime.getTime() + 60 * 60 * 1000);
                  const startHour = startTime.getHours();
                  const startMinute = startTime.getMinutes();
                  const duration = event.end_date
                    ? (endTime.getTime() - startTime.getTime()) /
                      (1000 * 60 * 60)
                    : 1;

                  // 겹침 처리: 중간 시작 이벤트는 양쪽을 모두 겹치게
                  const overlappingEvents = dayEvents.filter((e) => {
                    const eStartTime = parseISO(e.start_date);
                    const eEndTime = e.end_date ? parseISO(e.end_date) : new Date(eStartTime.getTime() + 60 * 60 * 1000);
                    
                    // 시간이 겹치는지 확인
                    return startTime < eEndTime && endTime > eStartTime;
                  });

                  let eventWidth, eventLeft, zIndex;
                  const dayWidth = `calc((100% - 60px) / 7)`; // 각 날짜 컬럼의 폭

                  if (overlappingEvents.length > 2) {
                    // 3개 이상 겹칠 때만 분할 처리
                    const sortedEvents = overlappingEvents.sort((a, b) => 
                      parseISO(a.start_date).getTime() - parseISO(b.start_date).getTime()
                    );

                    const currentEventIndex = sortedEvents.findIndex(e => e.id === event.id);
                    
                    if (currentEventIndex === 0) {
                      // 첫 번째 이벤트 - 왼쪽 절반
                      eventWidth = `calc((${dayWidth} / 2) - 4px)`;
                      eventLeft = `calc(60px + ${dayIndex} * ${dayWidth} + 2px)`;
                      zIndex = 10;
                    } else if (currentEventIndex === 1) {
                      // 두 번째 이벤트 - 오른쪽 절반
                      eventWidth = `calc((${dayWidth} / 2) - 4px)`;
                      eventLeft = `calc(60px + ${dayIndex} * ${dayWidth} + (${dayWidth} / 2) + 2px)`;
                      zIndex = 10;
                    } else {
                      // 중간에 시작하는 이벤트들 - 전체 너비에서 왼쪽 여백만 주고 양쪽 겹치게
                      eventWidth = `calc(${dayWidth} - 8px)`; // 왼쪽 여백 4px
                      eventLeft = `calc(60px + ${dayIndex} * ${dayWidth} + 6px)`;
                      zIndex = 20; // 위에 보이게
                    }
                  } else if (overlappingEvents.length === 2) {
                    // 2개만 겹칠 때 - 중간에 끼어드는 스타일로 처리
                    const sortedEvents = overlappingEvents.sort((a, b) => 
                      parseISO(a.start_date).getTime() - parseISO(b.start_date).getTime()
                    );

                    const currentEventIndex = sortedEvents.findIndex(e => e.id === event.id);
                    
                    if (currentEventIndex === 0) {
                      // 첫 번째 이벤트 - 전체 너비
                      eventWidth = `calc(${dayWidth} - 4px)`;
                      eventLeft = `calc(60px + ${dayIndex} * ${dayWidth} + 2px)`;
                      zIndex = 10;
                    } else {
                      // 두 번째 이벤트 - 중간에 끼어드는 스타일
                      eventWidth = `calc(${dayWidth} - 8px)`; // 왼쪽 여백 4px
                      eventLeft = `calc(60px + ${dayIndex} * ${dayWidth} + 6px)`;
                      zIndex = 20; // 위에 보이게
                    }
                  } else {
                    // 겹치지 않는 이벤트
                    eventWidth = `calc(${dayWidth} - 4px)`;
                    eventLeft = `calc(60px + ${dayIndex} * ${dayWidth} + 2px)`;
                    zIndex = 10;
                  }

                  const program = programs.find(
                    (p) => p.id === event.program_id
                  );

                  return (
                    <div
                      key={event.id}
                      className={`absolute p-1 border rounded cursor-pointer hover:shadow-md transition-shadow ${getTeamColor(
                        event.team_id
                      )}`}
                      style={{
                        left: eventLeft,
                        top: `${startHour * 70 + (startMinute / 60) * 70 + 2}px`,
                        width: eventWidth,
                        height: `${Math.max(duration * 70 - 4, 26)}px`,
                        fontSize: "10px",
                        zIndex: zIndex,
                        border: zIndex === 20 ? '1px solid white' : undefined, // 중간 끼어드는 이벤트에 흰색 보더
                        ...getTeamStyle(event.team_id),
                      }}
                      title={`${event.title} - ${program?.name || "프로그램"}`}
                      onClick={() => {
                        setSelectedEvent(event);
                        setIsEventDetailModalOpen(true);
                      }}
                    >
                      <div
                        className="font-medium text-xs leading-tight overflow-hidden"
                        style={{
                          wordBreak: "break-word",
                          display: "-webkit-box",
                          WebkitLineClamp: Math.max(
                            Math.floor(duration * 3),
                            1
                          ),
                          WebkitBoxOrient: "vertical",
                        }}
                      >
                        {event.title}
                      </div>
                      {program &&
                        overlappingEvents.length === 1 &&
                        duration > 1 && (
                          <div
                            className="opacity-75 text-xs leading-tight overflow-hidden mt-1"
                            style={{
                              wordBreak: "break-word",
                              display: "-webkit-box",
                              WebkitLineClamp: Math.max(
                                Math.floor(duration * 2),
                                1
                              ),
                              WebkitBoxOrient: "vertical",
                            }}
                          >
                            {program.name}
                          </div>
                        )}
                    </div>
                  );
                });
              })}
            </div>
          </div>
        )}

        {/* 월간 보기 */}
        {viewMode === "month" && (
          <div>
            {/* 요일 헤더 */}
            <div className="grid grid-cols-7 border-b">
              {["일", "월", "화", "수", "목", "금", "토"].map(
                (day, index) => (
                  <div
                    key={day}
                    className={`p-3 text-center text-sm font-medium border-r last:border-r-0 ${
                      index === 0
                        ? "text-red-600"
                        : index === 6
                          ? "text-blue-600"
                          : "text-gray-700"
                    }`}
                  >
                    {day}
                  </div>
                )
              )}
            </div>

            {/* 날짜 그리드 */}
            <div className="grid grid-cols-7">
              {monthDays.map((day, index) => {
                const dayEvents = getEventsForDay(day);
                const isCurrentMonth = isSameMonth(day, currentDate);
                const isToday = isSameDay(day, new Date());

                return (
                  <div
                    key={day.toISOString()}
                    className={`min-h-[80px] p-2 border-b border-r last:border-r-0 cursor-pointer hover:bg-gray-50 transition-colors ${
                      !isCurrentMonth ? "bg-gray-50 opacity-50" : ""
                    } ${isToday ? "bg-blue-50" : ""}`}
                    onClick={() => handleDateClick(day)}
                    title={
                      dayEvents.length > 0
                        ? `${format(day, "yyyy년 M월 d일", { locale: ko })}\n${dayEvents.length}개의 일정:\n${dayEvents.map((e) => `• ${e.title}`).join("\n")}`
                        : `${format(day, "yyyy년 M월 d일", { locale: ko })}\n등록된 일정이 없습니다.`
                    }
                  >
                    <div
                      className={`text-sm font-medium mb-1 ${
                        index % 7 === 0
                          ? "text-red-600"
                          : index % 7 === 6
                            ? "text-blue-600"
                            : "text-gray-700"
                      }`}
                    >
                      {format(day, "d")}
                    </div>

                    <div className="space-y-1">
                      {dayEvents.slice(0, 2).map((event) => {
                        const program = programs.find(
                          (p) => p.id === event.program_id
                        );
                        return (
                          <div
                            key={event.id}
                            className={`text-xs p-1 rounded border cursor-pointer hover:shadow-sm transition-shadow ${getTeamColor(
                              event.team_id
                            )}`}
                            style={{
                              ...getTeamStyle(event.team_id),
                            }}
                            title={`${event.title} - ${program?.name || "프로그램"}`}
                            onClick={(e) => {
                              e.stopPropagation();
                              setSelectedEvent(event);
                              setIsEventDetailModalOpen(true);
                            }}
                          >
                            <div className="font-medium truncate">
                              {event.title}
                            </div>
                          </div>
                        );
                      })}
                      {dayEvents.length > 2 && (
                        <Button
                          variant="ghost"
                          size="sm"
                          className="text-xs text-gray-500 h-6 px-2 py-1 w-full"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDateClick(day);
                          }}
                        >
                          +{dayEvents.length - 2} 더보기
                        </Button>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}